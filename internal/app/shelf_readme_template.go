package app

import (
	"fmt"
	"strings"
	"time"

	"github.com/blackwell-systems/shelfctl/internal/catalog"
)

// generateShelfREADME creates a README.md template for a new shelf
func generateShelfREADME(shelfName, repoName, owner string) string {
	now := time.Now().Format("2006-01-02")

	return fmt.Sprintf(`# %s

A curated collection managed with [shelfctl](https://github.com/blackwell-systems/shelfctl).

## About This Shelf

<!-- Add a description of what this shelf contains -->

Created: %s

## Quick Stats

- **Books**: 0
- **Last Updated**: %s

## Adding Books

Add books to this shelf using:

`+"```"+`bash
shelfctl shelve ~/Downloads/book.pdf --shelf %s --title "Book Title" --author "Author Name"
`+"```"+`

Or use the interactive workflow:

`+"```"+`bash
shelfctl shelve
`+"```"+`

## Browsing

View books in this shelf:

`+"```"+`bash
shelfctl browse --shelf %s
`+"```"+`

## Organization

<!-- You can organize books here by topic, reading status, etc. -->

### By Topic

<!-- Example:
- **Algorithms**: book-id-1, book-id-2
- **Systems**: book-id-3, book-id-4
-->

### Reading Lists

<!-- Example:
- **Currently Reading**: book-id-1
- **Want to Read**: book-id-2, book-id-3
- **Completed**: book-id-4
-->

### Favorites

<!-- Add your favorite books here -->

## Maintenance

This shelf is managed with shelfctl. The source of truth for metadata is `+"`catalog.yml`"+`.

- **View catalog**: `+"`cat catalog.yml`"+`
- **Validate**: `+"`shelfctl shelves`"+`
- **Split shelf**: `+"`shelfctl split`"+` (when it grows large)

## Links

- [shelfctl Documentation](https://github.com/blackwell-systems/shelfctl)
- [Release Assets](%s)

---

*Generated by shelfctl on %s*
`, shelfName, now, now, shelfName, shelfName,
		fmt.Sprintf("https://github.com/%s/%s/releases", owner, repoName), now)
}

// updateShelfREADMEStats updates the stats section of an existing README
func updateShelfREADMEStats(existingREADME string, bookCount int) string {
	now := time.Now().Format("2006-01-02")

	// Find and replace the Quick Stats section
	lines := strings.Split(existingREADME, "\n")
	var result []string
	inStatsSection := false
	statsReplaced := false

	for i, line := range lines {
		if strings.HasPrefix(line, "## Quick Stats") {
			inStatsSection = true
			result = append(result, line)
			result = append(result, "")
			result = append(result, fmt.Sprintf("- **Books**: %d", bookCount))
			result = append(result, fmt.Sprintf("- **Last Updated**: %s", now))
			statsReplaced = true
			continue
		}

		if inStatsSection {
			// Skip old stats lines until next section
			if strings.HasPrefix(line, "##") {
				inStatsSection = false
				result = append(result, "")
				result = append(result, line)
			}
			continue
		}

		// Keep lines outside stats section
		result = append(result, line)

		// If we're at the end and never found stats section, don't add anything
		if i == len(lines)-1 && !statsReplaced {
			return existingREADME // Return unchanged if no stats section found
		}
	}

	return strings.Join(result, "\n")
}

// appendToShelfREADME adds a new book entry to a "Recently Added" section
func appendToShelfREADME(existingREADME string, book catalog.Book) string {
	// Find "## Recently Added" section or create it after "## Quick Stats"
	lines := strings.Split(existingREADME, "\n")

	// Check if "Recently Added" section exists
	recentlyAddedIdx := -1
	quickStatsIdx := -1

	for i, line := range lines {
		if strings.HasPrefix(line, "## Recently Added") {
			recentlyAddedIdx = i
			break
		}
		if strings.HasPrefix(line, "## Quick Stats") {
			quickStatsIdx = i
		}
	}

	bookEntry := fmt.Sprintf("- **%s** by %s (`%s`)", book.Title, book.Author, book.ID)
	if len(book.Tags) > 0 {
		bookEntry += fmt.Sprintf(" - Tags: %s", strings.Join(book.Tags, ", "))
	}

	var result []string

	if recentlyAddedIdx >= 0 {
		// Section exists, add to it (keep last 10 entries)
		for i, line := range lines {
			result = append(result, line)
			if i == recentlyAddedIdx+1 {
				// Insert new entry after the header
				result = append(result, "")
				result = append(result, bookEntry)
			}
		}
	} else if quickStatsIdx >= 0 {
		// Create new section after Quick Stats
		for i, line := range lines {
			result = append(result, line)
			if i == quickStatsIdx {
				// Find end of Quick Stats section
				for j := i + 1; j < len(lines); j++ {
					result = append(result, lines[j])
					if strings.HasPrefix(lines[j], "##") {
						// Found next section, insert before it
						result = result[:len(result)-1] // Remove the section header we just added
						result = append(result, "")
						result = append(result, "## Recently Added")
						result = append(result, "")
						result = append(result, bookEntry)
						result = append(result, "")
						result = append(result, lines[j]) // Add back the section header
						// Add rest of lines
						result = append(result, lines[j+1:]...)
						return strings.Join(result, "\n")
					}
				}
			}
		}
	} else {
		// No Quick Stats section found, just append at end
		result = lines
		result = append(result, "")
		result = append(result, "## Recently Added")
		result = append(result, "")
		result = append(result, bookEntry)
	}

	return strings.Join(result, "\n")
}
